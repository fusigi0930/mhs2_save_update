#include "csaveupdater.h"
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <experimental/filesystem>
#include <QDebug>

#define ADDR_MONEY                  0x48
#define ADDR_ITEM_BEGIN             0x54
#define ADDR_ITEM_FLAG_BEGIN        0x12b68
#define ADDR_WEAPON_BEGIN           0x3ecc

#define WEAPON_EMPTY                0x7fff

#define ARRAY_SIZE(e) static_cast<int>(sizeof(e)/sizeof(e[0]))

#define UPDATE_SAVEDATA(m,a,v) \
    for (int i=0; i<ARRAY_SIZE(a); i++) { \
        update_item(m, a[i], v); \
    }

namespace fs = std::experimental::filesystem;

static uint16_t sItemRecover[] = {
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x10, 0x11,
    0x12, 0x13, 0x14, 0x15, 0x16, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1F, 0x20, 0x21, 0x24,
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0x5c7, 0x5c8, 0x5ce
};

static uint16_t sItemSupport[] = {
    0x2E, 0x2F, 0x4F, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x8C, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94
};

static uint16_t sItemGrowup[] = {
    0x9F, 0xA0, 0xA1, 0x116, 0x117, 0x118, 0x119, 0x11A, 0x11B, 0x11C, 0x11D, 0x11E, 0x11F, 0x120, 0x121
};

static uint16_t sItemBuilding[] = {
    0x1B1, 0x1B2, 0x1B3, 0x1B4, 0x1B5, 0x1B6, 0x1B7, 0x1B8, 0x1B9, 0x1BA, 0x1BB,
    0x1C2, 0x1C3, 0x1D0, 0x1D2, 0x1DE, 0x1E9, 0x1EC, 0x1F1, 0x1F3, 0x1F5, 0x1F6,
    0x1F7, 0x1F8, 0x2C7, 0x2C8
};

static uint16_t sItemSource[] = {
    0x81, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0x1CF, 0x1D1, 0x1D3,
    0x1D6, 0x1D7, 0x1D8, 0x1D9, 0x1DA, 0x1DB, 0x1DC, 0x1DD, 0x1DF, 0x1E0, 0x1E1,
    0x1E2, 0x1E3, 0x1E4, 0x1E5, 0x1E6, 0x1E7, 0x1E8, 0x1EA, 0x1EB, 0x1ED, 0x1EE,
    0x1EF, 0x1F0, 0x1F2, 0x1F4, 0x1F9, 0x1FE, 0x202, 0x20D, 0x20E, 0x20F, 0x210,
    0x211, 0x212, 0x216, 0x227, 0x228, 0x229, 0x22A, 0x22B, 0x23A, 0x23B, 0x23C,
    0x23D, 0x23E, 0x23F, 0x240, 0x241, 0x242, 0x252, 0x253, 0x254, 0x255, 0x256,
    0x257, 0x258, 0x259, 0x25A, 0x25B, 0x25F, 0x260, 0x261, 0x262, 0x263, 0x264,
    0x265, 0x266, 0x267, 0x268, 0x269, 0x26A, 0x26B, 0x26E, 0x279, 0x27A, 0x27B,
    0x27C, 0x27D, 0x27E, 0x27F, 0x281, 0x283, 0x284, 0x286, 0x287, 0x288, 0x2AF,
    0x2B0, 0x2B1, 0x2B2, 0x2B3, 0x2B4, 0x2C5, 0x2D1, 0x2D3, 0x2D5, 0x2D6, 0x2D7,
    0x2D8, 0x2D9, 0x2DA, 0x2DB, 0x2DC, 0x2DD, 0x2DE, 0x2DF, 0x2E0, 0x2E1, 0x2E2,
    0x2E3, 0x2E4, 0x2E5, 0x2E6, 0x2E7, 0x2E8, 0x2E9, 0x2F6, 0x2F7, 0x2F8, 0x2F9,
    0x2FA, 0x2FB, 0x2FC, 0x2FD, 0x2FE, 0x2FF, 0x300, 0x301, 0x302, 0x303, 0x304,
    0x305, 0x306, 0x307, 0x308, 0x309, 0x30A, 0x30B, 0x30C, 0x30D, 0x30E, 0x30F,
    0x310, 0x311, 0x312, 0x313, 0x314, 0x315, 0x316, 0x317, 0x318, 0x319, 0x31A,
    0x31B, 0x31C, 0x31D, 0x31E, 0x31F, 0x320, 0x321, 0x322, 0x323, 0x324, 0x325,
    0x326, 0x327, 0x328, 0x329, 0x32A, 0x32B, 0x32C, 0x32D, 0x32E, 0x32F, 0x330,
    0x331, 0x332, 0x333, 0x334, 0x335, 0x336, 0x337, 0x338, 0x339, 0x33A, 0x33B,
    0x33C, 0x33D, 0x33E, 0x33F, 0x340, 0x341, 0x342, 0x343, 0x344, 0x345, 0x346,
    0x347, 0x348, 0x349, 0x34A, 0x34B, 0x34C, 0x34D, 0x34E, 0x34F, 0x350, 0x351,
    0x352, 0x353, 0x354, 0x355, 0x356, 0x357, 0x358, 0x359, 0x35A, 0x35B, 0x35C,
    0x35D, 0x35E, 0x35F, 0x360, 0x361, 0x362, 0x363, 0x364, 0x365, 0x366, 0x367,
    0x368, 0x369, 0x36A, 0x36B, 0x36C, 0x36D, 0x36E, 0x36F, 0x370, 0x371, 0x372,
    0x373, 0x374, 0x375, 0x376, 0x377, 0x378, 0x379, 0x37A, 0x37B, 0x37C, 0x37D,
    0x37E, 0x37F, 0x380, 0x381, 0x382, 0x383, 0x384, 0x385, 0x386, 0x387, 0x388,
    0x389, 0x38A, 0x38B, 0x38C, 0x38D, 0x38E, 0x38F, 0x390, 0x391, 0x392, 0x393,
    0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E,
    0x39F, 0x3A0, 0x3A1, 0x3A2, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9,
    0x3AA, 0x3AB, 0x3AC, 0x3AD, 0x3AE, 0x3AF, 0x3B0, 0x3B1, 0x3B2, 0x3B3, 0x3B4,
    0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF,
    0x3C0, 0x3C1, 0x3C2, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA,
    0x3CB, 0x3CC, 0x3CD, 0x3CE, 0x3CF, 0x3D0, 0x3D1, 0x3D2, 0x3D3, 0x3D4, 0x3D5,
    0x3D6, 0x3D7, 0x3D8, 0x3D9, 0x3DA, 0x3DB, 0x3DC, 0x3DD, 0x3DE, 0x3DF, 0x3E0,
    0x3E1, 0x3E2, 0x3E3, 0x3E4, 0x3E5, 0x3E6, 0x3E7, 0x3E8, 0x3E9, 0x3EA, 0x3EB,
    0x3EC, 0x3ED, 0x3EE, 0x3EF, 0x3F0, 0x3F1, 0x3F2, 0x3F3, 0x3F4, 0x3F5, 0x3F6,
    0x3F7, 0x3F8, 0x3F9, 0x3FA, 0x3FB, 0x3FC, 0x3FD, 0x3FE, 0x3FF, 0x400, 0x401,
    0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C,
    0x40D, 0x40E, 0x40F, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417,
    0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422,
    0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D,
    0x42E, 0x42F, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438,
    0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443,
    0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E,
    0x44F, 0x450, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459,
    0x45A, 0x45B, 0x45C, 0x45D, 0x45E, 0x45F, 0x460, 0x461, 0x462, 0x463, 0x464,
    0x465, 0x466, 0x467, 0x468, 0x469, 0x46A, 0x46B, 0x46C, 0x46D, 0x46E, 0x46F,
    0x470, 0x471, 0x472, 0x473, 0x474, 0x475, 0x476, 0x477, 0x478, 0x47F, 0x480,
    0x481, 0x482, 0x483, 0x484, 0x485, 0x486, 0x487, 0x488, 0x489, 0x48A, 0x48C,
    0x48D, 0x48E, 0x48F, 0x490, 0x491, 0x492, 0x493, 0x494, 0x495, 0x496, 0x497,
    0x498, 0x499, 0x49A, 0x49B, 0x49C, 0x49D, 0x49E, 0x49F, 0x4A0, 0x4A1, 0x4A2,
    0x4A3, 0x4A4, 0x4A5, 0x4A6, 0x4A7, 0x4A8, 0x4A9, 0x4AA, 0x4AB, 0x4AC, 0x4AD,
    0x4AE, 0x4AF, 0x4B0, 0x4B1, 0x4B2, 0x4B4, 0x4B5, 0x4B6, 0x4B7, 0x4B8, 0x4B9,
    0x4BA, 0x4BB, 0x4BC, 0x4BD, 0x4BE, 0x4BF, 0x4C0, 0x4C1, 0x4C2, 0x4C3, 0x4C4,
    0x4C5, 0x4C6, 0x4C7, 0x4C8, 0x4C9,
    0x5CF, 0x5D0, 0x5D1, 0x5D2, 0x5D3, 0x5D4, 0x5D5, 0x5D6, 0x5D7, 0x5D8, 0x5D9,
    0x5DA, 0x5DB, 0x5DC, 0x5DD, 0x5DE, 0x5DF, 0x5E0, 0x5E1, 0x5E2, 0x5E3, 0x5E4,
    0x5E5, 0x5E6, 0x5E7, 0x5E8, 0x5E9, 0x5EA, 0x5EB, 0x5EC, 0x5ED, 0x5EE, 0x5EF,
    0x5F0, 0x5F1, 0x5F2, 0x5F3, 0x5F4, 0x5F5, 0x5F6, 0x5F7, 0x5F8, 0x5F9, 0x5FA,
    0x5FB, 0x5FC, 0x5FD, 0x5FE, 0x5FF, 0x600, 0x601, 0x602, 0x603, 0x604, 0x605,
    0x606, 0x607, 0x608, 0x609, 0x60A, 0x60B, 0x60C, 0x60D, 0x60E, 0x60F, 0x610,
    0x611, 0x612, 0x613, 0x614, 0x615, 0x616, 0x617, 0x618, 0x619, 0x61A, 0x61B,
    0x61C, 0x61D, 0x61E, 0x61F, 0x620, 0x621, 0x622, 0x623, 0x624, 0x625, 0x626,
    0x627, 0x628, 0x629, 0x62A, 0x62B, 0x62C, 0x62D, 0x62E, 0x62F, 0x630, 0x631,
    0x632, 0x633, 0x634, 0x635, 0x636, 0x637, 0x638, 0x639, 0x63A, 0x63B, 0x63C,
    0x63D, 0x63E, 0x63F, 0x640, 0x641, 0x642, 0x643, 0x644, 0x645, 0x646, 0x647,
    0x648, 0x649, 0x64A, 0x64B, 0x64C, 0x64D, 0x64E, 0x64F, 0x650, 0x651, 0x652,
    0x653, 0x654, 0x655, 0x656, 0x657, 0x658, 0x659, 0x65A, 0x65B, 0x65C, 0x65D,
    0x65E, 0x65F, 0x660, 0x661, 0x662, 0x663, 0x664, 0x665, 0x666
};

struct __attribute__((__packed__)) SItem {
    uint16_t id;
    uint16_t count;
    uint32_t reseve;
};

struct __attribute__((__packed__)) SWeapon {
    uint16_t type;
    uint16_t id;
    uint16_t level;
    uint8_t reserve[30];
};

static void update_item(unsigned char* buf, uint16_t id, uint16_t count) {
    if (nullptr == buf) return;

    unsigned char* item_addr = buf + ADDR_ITEM_BEGIN + ((id - 1) * sizeof(SItem));
    SItem *item = reinterpret_cast<SItem *>(item_addr);
    if (0 == count) {
        item->id = 0;
        item->count = 0;
    }
    else {
        item->id = id;
        item->count = count;
    }

    unsigned char* flag_addr = buf + ADDR_ITEM_FLAG_BEGIN + (id / 8);
    unsigned char bits = static_cast<unsigned char>(1) << (id % 8);
    if (0 == count) {
        *flag_addr = *flag_addr & ~bits;
    }
    else {
        *flag_addr = *flag_addr | bits;
    }
}

CSaveUpdater::CSaveUpdater(QObject *parent) : QObject(parent)
{

}

CSaveUpdater::~CSaveUpdater() {

}

void CSaveUpdater::save_update(QString filename, QString count) {
    std::string fname = reinterpret_cast<char*>(filename.toUtf8().data());
    fs::path p(fname.c_str());
    if (!fs::exists(p)) {
        std::stringstream s;
        s << "file: " << fname << "dose not exist!";
        emit sigErrorMessage(s.str().c_str());
        return;
    }

    std::string szBak = p.filename().string();
    szBak.append(".super.bak");

    std::ifstream f(fname.c_str(), std::ios::binary);
    std::vector<unsigned char> fbuf(std::istreambuf_iterator<char>(f), {});
    f.close();

    std::ofstream bkfile(szBak.c_str(), std::ios::binary);
    bkfile.write(reinterpret_cast<char*>(&fbuf[0]), fbuf.size());
    bkfile.close();

    uint32_t *pMoney = reinterpret_cast<uint32_t*>(&fbuf[ADDR_MONEY]);
    *pMoney = 0x7fffffff;
    int nCount = 999;
    if (!count.isEmpty()) {
        nCount = count.toInt();
    }

    UPDATE_SAVEDATA(&fbuf[0], sItemRecover, nCount);
    UPDATE_SAVEDATA(&fbuf[0], sItemSupport, nCount);
    UPDATE_SAVEDATA(&fbuf[0], sItemGrowup, nCount);
    UPDATE_SAVEDATA(&fbuf[0], sItemBuilding, nCount);
    UPDATE_SAVEDATA(&fbuf[0], sItemSource, nCount);

    std::ofstream ofile(fname.c_str(), std::ios::binary);
    ofile.write(reinterpret_cast<char*>(&fbuf[0]), fbuf.size());
    ofile.close();
}

void CSaveUpdater::save_adjust(QString filename, QString id, QString count) {
    int nID = 0;
    if (0 == id.toLower().left(2).compare("0x"))
        nID = id.toInt(nullptr, 16);
    else
        nID = id.toInt(nullptr, 10);
    int nCount = count.toInt();
    std::string fname = reinterpret_cast<char*>(filename.toUtf8().data());
    fs::path p(fname.c_str());
    if (!fs::exists(p)) {
        std::stringstream s;
        s << "file: " << fname << "dose not exist!";
        emit sigErrorMessage(s.str().c_str());
        return;
    }

    qDebug("id: 0x%x, %s, count: %d", nID, id.toUtf8().data(), nCount);
    std::ifstream f(fname.c_str(), std::ios::binary);
    std::vector<unsigned char> fbuf(std::istreambuf_iterator<char>(f), {});
    f.close();

    uint32_t *pMoney = reinterpret_cast<uint32_t*>(&fbuf[ADDR_MONEY]);
    *pMoney = 0x7fffffff;

    update_item(&fbuf[0], static_cast<uint16_t>(nID), static_cast<uint16_t>(nCount));

    std::ofstream ofile(fname.c_str(), std::ios::binary);
    ofile.write(reinterpret_cast<char*>(&fbuf[0]), fbuf.size());
    ofile.close();
}

void CSaveUpdater::save_addWeapon(QString filename) {
    std::string fname = reinterpret_cast<char*>(filename.toUtf8().data());
    fs::path p(fname.c_str());
    if (!fs::exists(p)) {
        std::stringstream s;
        s << "file: " << fname << "dose not exist!";
        emit sigErrorMessage(s.str().c_str());
        return;
    }

    std::ifstream f(fname.c_str(), std::ios::binary);
    std::vector<unsigned char> fbuf(std::istreambuf_iterator<char>(f), {});
    f.close();

    unsigned char* addr = &fbuf[0] + ADDR_WEAPON_BEGIN;
    SWeapon *pWeapon = reinterpret_cast<SWeapon*>(addr);
    while (WEAPON_EMPTY != pWeapon->type) {
        pWeapon = pWeapon + 1;
    }

    pWeapon->type = 0;
    pWeapon->id = 0x16;
    pWeapon->level = 1;

    std::ofstream ofile(fname.c_str(), std::ios::binary);
    ofile.write(reinterpret_cast<char*>(&fbuf[0]), fbuf.size());
    ofile.close();
}
